## 常见事件

鼠标事件、键盘事件、定时器、上下文菜单事件、关闭事件、拖放事件、绘制事件。

### 鼠标事件与常用函数：

需要包含头文件及函数名：

```C++
#include <QMouseEvent>
// 重写方法
protected:
	void mousePressEvent(QMouseEvent *event) override;		// 鼠标按下事件
	void mouseMoveEvent(QMouseEvent *event) override;		// 鼠标移动事件
	void mouseReleaseEvent(QMouseEvent *event) override;	// 鼠标释放事件
	void mouseDoubleClickEvent(QMouseEvent *event) override; // 鼠标双击事件
	void wheelEvent(QWheelEvent *event) override;			// 鼠标滚轮事件
```

几个鼠标事件的常用函数:

```C++
Qt::MouseButton button() const
event->button()    // 返回引起事件的按钮
QPoint QMouseEvent::globalPos() const
event->globalPos() // 返回鼠标光标在事件发生时的全局位置。
// 注意：他的(0, 0)坐标是电脑窗体的左上角，获取的坐标是基于整个电脑窗体的。
QPoint pos() const
event->pos() // 返回鼠标光标相对于接收事件的小部件的位置。
// 也即是说，他的(0, 0)坐标是运行窗体的左上角，获取的坐标是窗体中的坐标
```

参考连接-[Qt 鼠标事件 与 键盘事件_qt shift_cpp_learners的博客-CSDN博客](https://blog.csdn.net/cpp_learner/article/details/114407707)

鼠标按下事件：

```C++
void mousePressEvent(QMouseEvent *event) override;
void MouseEvent::mousePressEvent(QMouseEvent *event) {
	// 鼠标左键按下
	if (event->button() == Qt::LeftButton) {
	// 鼠标中键按下
	} else if (event->button() == Qt::MidButton) {
	// 鼠标右键按下
	} else if (event->button() == Qt::RightButton) {
	}
}
```

鼠标移动事件：

鼠标在窗体上移动时促发。但是，为了节省耗能，需要鼠标按下后才会促发此函数。
如果我们有需求，不需要按下鼠标键就可以促发鼠标移动事件：

```c++
// 在Widget中可以在构造函数中加上这句：
this->setMouseTracking(true);
```

```c++
// 在MainWindow中
ui.centralWidget->setMouseTracking(true);// 开启UI中的移动监视
this->setMouseTracking(true);
```

### 键盘事件以及常用函数：

键盘事件有两个，键盘按下事件与键盘释放事件。

```c++
#include <QKeyEvent>
protected:
	void keyPressEvent(QKeyEvent *event) override;	 // 键盘按下事件
	void keyReleaseEvent(QKeyEvent *event) override; // 键盘释放事件
```

常用函数：

```C++
int QKeyEvent::key() const
event->key()// 返回被按下或释放的键的代码。
// 也就是说，按下哪个键，就返回哪个键。
Qt::KeyboardModifiers QKeyEvent::modifiers() const
event->modifiers() // 返回事件发生后立即存在的键盘修饰符标志。
// 例如alt键，ctrl键，shift键。
QString QKeyEvent::text() const
event->text() // 返回此键生成的Unicode文本。
// 也就是说返回键盘按下的文本。
```

回车键是`Qt::Key_Return`
如需按下修饰键，需要使用modifiers()方法进行返回按下的修饰键。
alt键：`Qt::AltModifier` ctrl键：`Qt::ControlModifier` shift键：`Qt::ShiftModifier`

```c++
void keyPressEvent(QKeyEvent *event) override;
void KeyEvent::keyPressEvent(QKeyEvent *event) {
	// 按下修饰键，且按下的键时ctlr
	if (event->modifiers() == Qt::ControlModifier) {	
		if (event->key() == Qt::Key_Left) {	// 左键按下
		} else if (event->key() == Qt::Key_Right) {	// 右键按下
		} else if (event->key() == Qt::Key_Up) {	// 上键按下
		} else if (event->key() == Qt::Key_Down) {	// 下键按下
		} else if (event->key() == Qt::Key_1){ // 数字键1按下
         } else if (event->key() == Qt::Key_A){ // 字母键A按下
         }
	}    // 可以查阅相关枚举值得到想要的触发条件
}
```



### 定时器与随机数

```C++
startTimer(2200); // 2.2ms
```

  开启一个定时器函数 延时ms

定时器 `void timerEvent(QTimerEvent *event);` 定时器重写槽函数。

## connect 第五个参数注解

 `connect(QObject,signal,QObject,slots,connection，QT::ConnectionType)` 信号于槽连接的第五个参数：

`Qt::AutoConnection`  默认值，自动关联。如果receiver存在于（lives in）发射信号的线程（发射者与接收者在同一个线程），则使用`Qt::DirectConnection`；否则（发射者和接收者不在同一个线程），使用`Qt::QueuedConnection`。在信号 被发射是决定使用哪种关联类型。

`Qt::DirectConnection`  直接关联，发射完信号立即调用槽，只有槽执行完成返回后， 发射信号处，后面的代码才可以执行。

`Qt::QueueConnection`  队列关联。信号发出后，信号暂时被放到一个消息队列中。当控制返回received所在线程的事件循环后再执行槽。不需要等待槽执行完才执行后面的代码。 

`Qt::BlockingQueueConnection` 阻塞队列关联。类似 `Qt::QueueConnection`，不过，信号线程会一直阻赛，直到槽返回。当receiver存在于信号线程时不能使用该类型，不然程序会死锁。线程需要同步的场合可能需要这个。

`Qt::QueueConnection` 唯一关联。这是一个标志，可以结合其他几种连接类型，使用*按位或操作*。这时两个对象的相同的信号和槽只能有唯一的关联。使用这个标志主要防止重复关联。