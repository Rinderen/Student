## 常见事件

鼠标事件、键盘事件、定时器、上下文菜单事件、关闭事件、拖放事件、绘制事件。

### 鼠标事件及常用函数

需要包含头文件及函数名：

```C++
#include <QMouseEvent>
// 重写方法
protected:
	void mousePressEvent(QMouseEvent *event) override;		// 鼠标按下事件
	void mouseMoveEvent(QMouseEvent *event) override;		// 鼠标移动事件
	void mouseReleaseEvent(QMouseEvent *event) override;	// 鼠标释放事件
	void mouseDoubleClickEvent(QMouseEvent *event) override; // 鼠标双击事件
	void wheelEvent(QWheelEvent *event) override;			// 鼠标滚轮事件
```

几个鼠标事件的常用函数:

```C++
Qt::MouseButton button() const
event->button()    // 返回引起事件的按钮
QPoint QMouseEvent::globalPos() const
event->globalPos() // 返回鼠标光标在事件发生时的全局位置。
// 注意：他的(0, 0)坐标是电脑窗体的左上角，获取的坐标是基于整个电脑窗体的。
QPoint pos() const
event->pos() // 返回鼠标光标相对于接收事件的小部件的位置。
// 也即是说，他的(0, 0)坐标是运行窗体的左上角，获取的坐标是窗体中的坐标
```

参考连接-[Qt 鼠标事件 与 键盘事件_qt shift_cpp_learners的博客-CSDN博客](https://blog.csdn.net/cpp_learner/article/details/114407707)

鼠标按下事件：

```C++
void mousePressEvent(QMouseEvent *event) override;
void MouseEvent::mousePressEvent(QMouseEvent *event) {
	// 鼠标左键按下
	if (event->button() == Qt::LeftButton) {
	// 鼠标中键按下
	} else if (event->button() == Qt::MidButton) {
	// 鼠标右键按下
	} else if (event->button() == Qt::RightButton) {
	}
}
```

鼠标移动事件：

鼠标在窗体上移动时促发。但是，为了节省耗能，需要鼠标按下后才会促发此函数。
如果我们有需求，不需要按下鼠标键就可以促发鼠标移动事件：

```c++
// 在Widget中可以在构造函数中加上这句：
this->setMouseTracking(true);
```

```c++
// 在MainWindow中
ui.centralWidget->setMouseTracking(true);// 开启UI中的移动监视
this->setMouseTracking(true);
```

### 键盘事件及常用函数

键盘事件有两个，键盘按下事件与键盘释放事件。

```c++
#include <QKeyEvent>
protected:
	void keyPressEvent(QKeyEvent *event) override;	 // 键盘按下事件
	void keyReleaseEvent(QKeyEvent *event) override; // 键盘释放事件
```

常用函数：

```C++
int QKeyEvent::key() const
event->key()// 返回被按下或释放的键的代码。
// 也就是说，按下哪个键，就返回哪个键。
Qt::KeyboardModifiers QKeyEvent::modifiers() const
event->modifiers() // 返回事件发生后立即存在的键盘修饰符标志。
// 例如alt键，ctrl键，shift键。
QString QKeyEvent::text() const
event->text() // 返回此键生成的Unicode文本。
// 也就是说返回键盘按下的文本。
```

回车键是`Qt::Key_Return`
如需按下修饰键，需要使用modifiers()方法进行返回按下的修饰键。
alt键：`Qt::AltModifier` ctrl键：`Qt::ControlModifier` shift键：`Qt::ShiftModifier`

```c++
void keyPressEvent(QKeyEvent *event) override;
void KeyEvent::keyPressEvent(QKeyEvent *event) {
	// 按下修饰键，且按下的键时ctlr
	if (event->modifiers() == Qt::ControlModifier) {	
		if (event->key() == Qt::Key_Left) {	// 左键按下
		} else if (event->key() == Qt::Key_Right) {	// 右键按下
		} else if (event->key() == Qt::Key_Up) {	// 上键按下
		} else if (event->key() == Qt::Key_Down) {	// 下键按下
		} else if (event->key() == Qt::Key_1){ // 数字键1按下
         } else if (event->key() == Qt::Key_A){ // 字母键A按下
         }
	}    // 可以查阅相关枚举值得到想要的触发条件
}
```

### 定时器与随机数

定时器：

```C++
// widget.h
#include <QTimerEvent>
protected:
	void timerEvent(QTimerEvent *event);
private:
	int id1,id2,id3
// widget.cpp
#include <QDebug>
Widget::Widget(QWidget *parent):QWidget(parent),ui(new Ui::Widget){
    id1=startTimer(1000); // 开启一个1秒定时器，返回其ID
	id1=startTimer(1500);// 1.5
	id1=startTimer(2200);// 2.2ms
}   
void Widget::timerEvent(QTimerEvent *event)// 定时器重写槽函数
{
    if (event->timerId() == id1)      // 判断是哪个定时器
        qDebug() << "timer1";
    else if (event->timerId() == id2) 
        qDebug() << "timer2";
    else qDebug() << "timer3";
}
```

随机数：

在使用qrand产生随机数之前，一般需要使用qsrand函数为其设置初始值，如果不设置初始值，那么每次运行程序qrand()都会产生相同的一组随机数。

```C++
// widget.cpp
#include <QTimer>
#include <QTime>
Widget::Widget(QWidget *parent):QWidget(parent),ui(new Ui::Widget){
      QTimer *timer = new QTimer(this);           // 创建一个新的定时器
    //关联定时器的溢出信号
 connect(timer, &QTimer::timeout, this, &Widget::timerUpdate);
    timer->start(1000); //设置溢出时间为1s，并启动定时器
    qsrand(QTime(0,0,0).secsTo(QTime::currentTime()));// 随机数的产生QTime类
}   
void Widget::timerUpdate() //定时器溢出处理
{
    QTime time=QTime::currentTime();//获取当前时间
    QString text=time.toString("hh:mm");//转换为字符串 hh:mm形式
    if((time.second()%2)==0)
        text[2]=' ';//每隔一秒就将":"显示为空格
    ui->lcdNumber->display(text);
    
    int rand=qrand()%300;// 限定0-299之间
    ui->lcdNumber->move(rand,rand);// 随机移动LCD控件
}
```

QTimer类中还有一个singleShot函数来开启一个只运行一次的定时器，下面使用这个函数让程序运行10s后自动关闭。在widget.cpp文件中的构造函数里添加：

```C++
QTimer::singleShot(10000,this,&Widget::close);//设置时间10s,close函数
```

这里将时间设置为10 s,溢出时便调用窗口部件的close()函数来关闭窗口。可以运行一下程序,等待10 s,程序会自动退出

### 绘制事件

系统开始时、放大缩小、影响绘图区域的每一步操作，调用绘图事件

```C++
#include <QPainter>
[virtual protected] void QWidget::paintEvent(QPaintEvent *event) override;

// 界面初始化拉伸界面放大缩小会调用
void resizeEvent(QResizeEvent *event) override; // 重置大小
```



## connect 第五个参数注解

随机数ect,slots,connection，QT::ConnectionType)` 信号于槽连接的第五个参数：

`Qt::AutoConnection`  默认值，自动关联。如果receiver存在于（lives in）发射信号的线程（发射者与接收者在同一个线程），则使用`Qt::DirectConnection`；否则（发射者和接收者不在同一个线程），使用`Qt::QueuedConnection`。在信号 被发射是决定使用哪种关联类型。

`Qt::DirectConnection`  直接关联，发射完信号立即调用槽，只有槽执行完成返回后， 发射信号处，后面的代码才可以执行。

`Qt::QueueConnection`  队列关联。信号发出后，信号暂时被放到一个消息队列中。当控制返回received所在线程的事件循环后再执行槽。不需要等待槽执行完才执行后面的代码。 

`Qt::BlockingQueueConnection` 阻塞队列关联。类似 `Qt::QueueConnection`，不过，信号线程会一直阻赛，直到槽返回。当receiver存在于信号线程时不能使用该类型，不然程序会死锁。线程需要同步的场合可能需要这个。

`Qt::QueueConnection` 唯一关联。这是一个标志，可以结合其他几种连接类型，使用*按位或操作*。这时两个对象的相同的信号和槽只能有唯一的关联。使用这个标志主要防止重复关联。



## mvc架构



文件管理

文本操作

正则表达式